'use strict'
var rand = exports

const BN = require('bn.js')
const prime = require('./prime.js')

async function randomBytes (byteSize) {
  return rand.randomBytesImp(byteSize)
}
rand.randomBytes = randomBytes

async function randomBN (byteSize) {
  const buf = await randomBytes(byteSize)
  return new BN(buf.toString('hex'), 16)
}
rand.randomBN = randomBN

async function randomBNStrict (byteSize) {
  while(true){
    let buf = await randomBytes(byteSize)
    let hByte = buf.readUInt8(0)
    if(hByte >= 127){
      return new BN(buf.toString('hex'), 16)
    }
  }
}
rand.randomBNStrict = randomBNStrict

async function randomPrime(byteSize) {
  while(true){
    let r = await randomBN(byteSize)
    if(prime.isProbablyPrime(r)) {
      return r
    }
  }
}
rand.randomPrime = randomPrime

async function randomPrimeStrict(byteSize) {
  while(true){
    let r = await randomBNStrict(byteSize)
    if(prime.isProbablyPrime(r)) {
      return r
    }
  }
}
rand.randomPrimeStrict = randomPrimeStrict

async function randomPrime256Bit () {
    return await randomPrime(32)
}
rand.randomPrime256Bit = randomPrime256Bit

async function randomPrimeStrict256Bit () {
  return await randomPrimeStrict(32)
}
rand.randomPrimeStrict256Bit = randomPrimeStrict256Bit

async function randomBNLt(max) {
  let byteLen = 1
  if(max.bitLength() % 8 === 0){
    byteLen = max.bitLength() / 8
  }else {
    byteLen = Math.floor(max.bitLength()/8) + 1
  }
  while(true){
    let r = await randomBN(byteLen)
    r = r.mod(max)
    // to fix the bug in lib "bn.js" while byteLen === 1
    if(r.red){
      return r.fromRed()
    }else {
      return r
    }
  }
}
rand.randomBNLt= randomBNLt

// for pailliar cryptosystem
async function randomBNLtGCD(max) {
  while(true){
    let r = await randomBNLt(max)
    if(r.gcd(max).eqn(1)){
      return r
    }
  }
}
rand.randomBNLtGCD = randomBNLtGCD


